// Copyright Epic Games, Inc.

#include "GasXAttributeSetGenerator.h"
#include "Logging/LogMacros.h"
#include "Misc/FileHelper.h"
#include "Misc/Paths.h"
#include "HAL/PlatformFileManager.h"

DEFINE_LOG_CATEGORY_STATIC(LogGasXAttributeSetGenerator, Log, All);

bool FGasXAttributeSetGenerator::GenerateAttributeSet(
	const FGasXAttributeSetSchema &Schema,
	const FString &OutputHeaderPath,
	const FString &OutputSourcePath)
{
	FString ValidationError;
	if (!ValidateSchema(Schema, ValidationError))
	{
		UE_LOG(LogGasXAttributeSetGenerator, Error, TEXT("Schema validation failed: %s"), *ValidationError);
		return false;
	}

	if (!EnsureOutputDirectory(FPaths::GetPath(OutputHeaderPath)))
	{
		UE_LOG(LogGasXAttributeSetGenerator, Error, TEXT("Failed to create output directory for header: %s"), *OutputHeaderPath);
		return false;
	}

	if (!EnsureOutputDirectory(FPaths::GetPath(OutputSourcePath)))
	{
		UE_LOG(LogGasXAttributeSetGenerator, Error, TEXT("Failed to create output directory for source: %s"), *OutputSourcePath);
		return false;
	}

	FString HeaderContent = GenerateHeaderContent(Schema);
	FString SourceContent = GenerateSourceContent(Schema);

	if (!FFileHelper::SaveStringToFile(HeaderContent, *OutputHeaderPath, FFileHelper::EEncodingOptions::ForceUTF8WithoutBOM))
	{
		UE_LOG(LogGasXAttributeSetGenerator, Error, TEXT("Failed to write header file: %s"), *OutputHeaderPath);
		return false;
	}

	if (!FFileHelper::SaveStringToFile(SourceContent, *OutputSourcePath, FFileHelper::EEncodingOptions::ForceUTF8WithoutBOM))
	{
		UE_LOG(LogGasXAttributeSetGenerator, Error, TEXT("Failed to write source file: %s"), *OutputSourcePath);
		return false;
	}

	UE_LOG(LogGasXAttributeSetGenerator, Log, TEXT("Successfully generated AttributeSet: %s"), *Schema.AttributeSetClassName);
	UE_LOG(LogGasXAttributeSetGenerator, Log, TEXT("  Header: %s"), *OutputHeaderPath);
	UE_LOG(LogGasXAttributeSetGenerator, Log, TEXT("  Source: %s"), *OutputSourcePath);

	return true;
}

bool FGasXAttributeSetGenerator::ValidateSchema(const FGasXAttributeSetSchema &Schema, FString &OutError) const
{
	if (Schema.AttributeSetClassName.IsEmpty())
	{
		OutError = TEXT("AttributeSetClassName cannot be empty");
		return false;
	}

	if (!IsValidIdentifier(Schema.AttributeSetClassName))
	{
		OutError = FString::Printf(TEXT("AttributeSetClassName '%s' is not a valid C++ identifier"), *Schema.AttributeSetClassName);
		return false;
	}

	if (Schema.Attributes.Num() == 0)
	{
		OutError = TEXT("Schema must contain at least one attribute");
		return false;
	}

	TSet<FString> SeenNames;
	for (const FGasXAttributeDefinition &Attr : Schema.Attributes)
	{
		if (Attr.AttributeName.IsEmpty())
		{
			OutError = TEXT("Attribute name cannot be empty");
			return false;
		}

		FString LowerName = Attr.AttributeName.ToLower();
		if (SeenNames.Contains(LowerName))
		{
			OutError = FString::Printf(TEXT("Duplicate attribute name (case-insensitive): %s"), *Attr.AttributeName);
			return false;
		}
		SeenNames.Add(LowerName);

		if (!IsValidIdentifier(Attr.AttributeName))
		{
			OutError = FString::Printf(TEXT("Attribute name '%s' is not a valid C++ identifier"), *Attr.AttributeName);
			return false;
		}

		if (IsReservedKeyword(Attr.AttributeName))
		{
			OutError = FString::Printf(TEXT("Attribute name '%s' is a reserved C++ keyword"), *Attr.AttributeName);
			return false;
		}

		if (Attr.AttributeType != TEXT("float") && Attr.AttributeType != TEXT("int32"))
		{
			OutError = FString::Printf(TEXT("Attribute type '%s' not supported in MVP (use 'float' or 'int32')"), *Attr.AttributeType);
			return false;
		}
	}

	return true;
}

FString FGasXAttributeSetGenerator::GenerateHeaderContent(const FGasXAttributeSetSchema &Schema) const
{
	FString Header = TEXT("// Copyright Epic Games, Inc.\n");
	Header += TEXT("// AUTO-GENERATED by GasXAttributeSetGenerator - DO NOT EDIT MANUALLY\n\n");
	Header += TEXT("#pragma once\n\n");
	Header += TEXT("#include \"CoreMinimal.h\"\n");
	Header += TEXT("#include \"AttributeSet.h\"\n");
	Header += TEXT("#include \"AbilitySystemComponent.h\"\n");
	Header += FString::Printf(TEXT("#include \"%s.generated.h\"\n\n"), *Schema.AttributeSetClassName);

	Header += TEXT("/**\n");
	Header += FString::Printf(TEXT(" * Generated AttributeSet: %s\n"), *Schema.AttributeSetClassName);
	if (!Schema.Description.IsEmpty())
	{
		Header += FString::Printf(TEXT(" * %s\n"), *Schema.Description);
	}
	Header += TEXT(" */\n");
	Header += TEXT("UCLASS()\n");
	Header += FString::Printf(TEXT("class %s_API U%s : public UAttributeSet\n"), *Schema.TargetModule.ToUpper(), *Schema.AttributeSetClassName);
	Header += TEXT("{\n");
	Header += TEXT("\tGENERATED_BODY()\n\n");
	Header += TEXT("public:\n");
	Header += FString::Printf(TEXT("\tU%s();\n\n"), *Schema.AttributeSetClassName);

	// Generate attribute properties
	Header += TEXT("\t//GEN-BEGIN: Attribute Properties\n");
	for (const FGasXAttributeDefinition &Attr : Schema.Attributes)
	{
		Header += GenerateAttributeProperty(Attr);
	}
	Header += TEXT("\t//GEN-END: Attribute Properties\n\n");

	// Generate accessors
	Header += TEXT("\t//GEN-BEGIN: Attribute Accessors\n");
	for (const FGasXAttributeDefinition &Attr : Schema.Attributes)
	{
		Header += GenerateAccessors(Attr, Schema.AttributeSetClassName);
	}
	Header += TEXT("\t//GEN-END: Attribute Accessors\n\n");

	// Generate OnRep declarations
	Header += TEXT("\t//GEN-BEGIN: OnRep Functions\n");
	for (const FGasXAttributeDefinition &Attr : Schema.Attributes)
	{
		if (Attr.bReplicates && Attr.bRepNotify)
		{
			Header += GenerateOnRepDeclaration(Attr);
		}
	}
	Header += TEXT("\t//GEN-END: OnRep Functions\n\n");

	Header += TEXT("\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n");
	Header += TEXT("};\n");

	return Header;
}

FString FGasXAttributeSetGenerator::GenerateSourceContent(const FGasXAttributeSetSchema &Schema) const
{
	FString Source = TEXT("// Copyright Epic Games, Inc.\n");
	Source += TEXT("// AUTO-GENERATED by GasXAttributeSetGenerator - DO NOT EDIT MANUALLY\n\n");
	Source += FString::Printf(TEXT("#include \"Attributes/%s.h\"\n"), *Schema.AttributeSetClassName);
	Source += TEXT("#include \"Net/UnrealNetwork.h\"\n\n");

	// Constructor
	Source += FString::Printf(TEXT("U%s::U%s()\n"), *Schema.AttributeSetClassName, *Schema.AttributeSetClassName);
	Source += TEXT("{\n");
	Source += TEXT("\t//GEN-BEGIN: Constructor Initialization\n");
	for (const FGasXAttributeDefinition &Attr : Schema.Attributes)
	{
		Source += FString::Printf(TEXT("\t%s.SetBaseValue(%.2ff);\n"), *Attr.AttributeName, Attr.DefaultValue);
		Source += FString::Printf(TEXT("\t%s.SetCurrentValue(%.2ff);\n"), *Attr.AttributeName, Attr.DefaultValue);
	}
	Source += TEXT("\t//GEN-END: Constructor Initialization\n");
	Source += TEXT("}\n\n");

	// OnRep implementations
	Source += TEXT("//GEN-BEGIN: OnRep Implementations\n");
	for (const FGasXAttributeDefinition &Attr : Schema.Attributes)
	{
		if (Attr.bReplicates && Attr.bRepNotify)
		{
			Source += GenerateOnRepImplementation(Attr, Schema.AttributeSetClassName);
		}
	}
	Source += TEXT("//GEN-END: OnRep Implementations\n\n");

	// Replication setup
	Source += GenerateReplicationSetup(Schema);

	return Source;
}

FString FGasXAttributeSetGenerator::GenerateAttributeProperty(const FGasXAttributeDefinition &Attribute) const
{
	FString Property;
	if (!Attribute.Description.IsEmpty())
	{
		Property += FString::Printf(TEXT("\t/** %s */\n"), *Attribute.Description);
	}

	Property += TEXT("\tUPROPERTY(BlueprintReadOnly, Category=\"Attributes\"");
	if (Attribute.bReplicates && Attribute.bRepNotify)
	{
		Property += FString::Printf(TEXT(", ReplicatedUsing=OnRep_%s"), *Attribute.AttributeName);
	}
	Property += TEXT(")\n");
	Property += FString::Printf(TEXT("\tFGameplayAttributeData %s;\n\n"), *Attribute.AttributeName);

	return Property;
}

FString FGasXAttributeSetGenerator::GenerateOnRepDeclaration(const FGasXAttributeDefinition &Attribute) const
{
	FString Decl = TEXT("\tUFUNCTION()\n");
	Decl += FString::Printf(TEXT("\tvirtual void OnRep_%s(const FGameplayAttributeData& OldValue);\n\n"), *Attribute.AttributeName);
	return Decl;
}

FString FGasXAttributeSetGenerator::GenerateAccessors(const FGasXAttributeDefinition &Attribute, const FString &ClassName) const
{
	FString Accessors;
	Accessors += FString::Printf(TEXT("\tGAMEPLAYATTRIBUTE_PROPERTY_GETTER(U%s, %s)\n"), *ClassName, *Attribute.AttributeName);
	Accessors += FString::Printf(TEXT("\tGAMEPLAYATTRIBUTE_VALUE_GETTER(%s)\n"), *Attribute.AttributeName);
	Accessors += FString::Printf(TEXT("\tGAMEPLAYATTRIBUTE_VALUE_SETTER(%s)\n"), *Attribute.AttributeName);
	Accessors += FString::Printf(TEXT("\tGAMEPLAYATTRIBUTE_VALUE_INITTER(%s)\n\n"), *Attribute.AttributeName);
	return Accessors;
}

FString FGasXAttributeSetGenerator::GenerateOnRepImplementation(const FGasXAttributeDefinition &Attribute, const FString &ClassName) const
{
	FString Impl;
	Impl += FString::Printf(TEXT("void U%s::OnRep_%s(const FGameplayAttributeData& OldValue)\n"), *ClassName, *Attribute.AttributeName);
	Impl += TEXT("{\n");
	Impl += FString::Printf(TEXT("\tGAMEPLAYATTRIBUTE_REPNOTIFY(U%s, %s, OldValue);\n"), *ClassName, *Attribute.AttributeName);
	Impl += TEXT("}\n\n");
	return Impl;
}

FString FGasXAttributeSetGenerator::GenerateReplicationSetup(const FGasXAttributeSetSchema &Schema) const
{
	FString Repl;
	Repl += FString::Printf(TEXT("void U%s::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n"), *Schema.AttributeSetClassName);
	Repl += TEXT("{\n");
	Repl += TEXT("\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n");
	Repl += TEXT("\t//GEN-BEGIN: Replication Setup\n");
	for (const FGasXAttributeDefinition &Attr : Schema.Attributes)
	{
		if (Attr.bReplicates)
		{
			Repl += FString::Printf(TEXT("\tDOREPLIFETIME_CONDITION_NOTIFY(U%s, %s, COND_None, REPNOTIFY_Always);\n"),
									*Schema.AttributeSetClassName, *Attr.AttributeName);
		}
	}
	Repl += TEXT("\t//GEN-END: Replication Setup\n");
	Repl += TEXT("}\n");
	return Repl;
}

bool FGasXAttributeSetGenerator::EnsureOutputDirectory(const FString &DirectoryPath) const
{
	IPlatformFile &PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
	if (!PlatformFile.DirectoryExists(*DirectoryPath))
	{
		return PlatformFile.CreateDirectoryTree(*DirectoryPath);
	}
	return true;
}

bool FGasXAttributeSetGenerator::IsReservedKeyword(const FString &Name) const
{
	static const TSet<FString> ReservedKeywords = {
		TEXT("alignas"), TEXT("alignof"), TEXT("and"), TEXT("and_eq"), TEXT("asm"), TEXT("auto"),
		TEXT("bitand"), TEXT("bitor"), TEXT("bool"), TEXT("break"), TEXT("case"), TEXT("catch"),
		TEXT("char"), TEXT("char16_t"), TEXT("char32_t"), TEXT("class"), TEXT("compl"), TEXT("const"),
		TEXT("constexpr"), TEXT("const_cast"), TEXT("continue"), TEXT("decltype"), TEXT("default"),
		TEXT("delete"), TEXT("do"), TEXT("double"), TEXT("dynamic_cast"), TEXT("else"), TEXT("enum"),
		TEXT("explicit"), TEXT("export"), TEXT("extern"), TEXT("false"), TEXT("float"), TEXT("for"),
		TEXT("friend"), TEXT("goto"), TEXT("if"), TEXT("inline"), TEXT("int"), TEXT("long"),
		TEXT("mutable"), TEXT("namespace"), TEXT("new"), TEXT("noexcept"), TEXT("not"), TEXT("not_eq"),
		TEXT("nullptr"), TEXT("operator"), TEXT("or"), TEXT("or_eq"), TEXT("private"), TEXT("protected"),
		TEXT("public"), TEXT("register"), TEXT("reinterpret_cast"), TEXT("return"), TEXT("short"),
		TEXT("signed"), TEXT("sizeof"), TEXT("static"), TEXT("static_assert"), TEXT("static_cast"),
		TEXT("struct"), TEXT("switch"), TEXT("template"), TEXT("this"), TEXT("thread_local"),
		TEXT("throw"), TEXT("true"), TEXT("try"), TEXT("typedef"), TEXT("typeid"), TEXT("typename"),
		TEXT("union"), TEXT("unsigned"), TEXT("using"), TEXT("virtual"), TEXT("void"), TEXT("volatile"),
		TEXT("wchar_t"), TEXT("while"), TEXT("xor"), TEXT("xor_eq")};

	return ReservedKeywords.Contains(Name.ToLower());
}

bool FGasXAttributeSetGenerator::IsValidIdentifier(const FString &Name) const
{
	if (Name.IsEmpty())
	{
		return false;
	}

	// First character must be letter or underscore
	TCHAR FirstChar = Name[0];
	if (!FChar::IsAlpha(FirstChar) && FirstChar != TEXT('_'))
	{
		return false;
	}

	// Remaining characters must be alphanumeric or underscore
	for (int32 i = 1; i < Name.Len(); ++i)
	{
		TCHAR Ch = Name[i];
		if (!FChar::IsAlnum(Ch) && Ch != TEXT('_'))
		{
			return false;
		}
	}

	return true;
}
